<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Text - Hand Gestures</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #bg-video {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; z-index: -1; transform: scaleX(-1); filter: brightness(0.4);
        }
        canvas { display: block; position: absolute; top: 0; left: 0; }
        
        #instruction {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.6); font-size: 14px; text-align: center;
            pointer-events: none; line-height: 1.6;
        }
        #current-word-indicator {
            position: absolute; top: 30px; right: 30px; color: white;
            font-size: 12px; opacity: 0.5; letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <video id="webcam" playsinline style="display:none;"></video>
    <video id="bg-video" playsinline></video>
    
    <div id="current-word-indicator">MODE: INTERACTIVE PARTICLES</div>
    <div id="instruction">
        CHẠM TAY để làm tan rã chữ <br> 
        LƯỚT NHANH SANG TRÁI/PHẢI để đổi nội dung
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CẤU HÌNH ---
        const words = ["Hello", "Demen799", "Trùm trường", ":))"];
        let currentWordIndex = 0;
        const softColors = [0x95d5b2, 0xa2d2ff, 0xefc3e6, 0xfdf0d5]; // Màu Pastel nhạt

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 500;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // --- PARTICLE LOGIC ---
        let particles = [];
        const particleGeometry = new THREE.BufferGeometry();
        const texture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/sprites/disc.png');
        const particleMaterial = new THREE.PointsMaterial({
            size: 4,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            map: texture,
            blending: THREE.AdditiveBlending,
            depthTest: false
        });

        const pointsMesh = new THREE.Points(particleGeometry, particleMaterial);
        scene.add(pointsMesh);

        // Hàm tạo tọa độ từ chữ (Canvas Sampling)
        function createTextData(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1000;
            canvas.height = 300;
            
            ctx.fillStyle = 'white';
            ctx.font = '900 120px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(text, 500, 150);

            const imageData = ctx.getImageData(0, 0, 1000, 300).data;
            const newPositions = [];
            
            // Lấy mẫu các pixel có màu
            for (let y = 0; y < 300; y += 4) {
                for (let x = 0; x < 1000; x += 4) {
                    const index = (x + y * 1000) * 4;
                    if (imageData[index] > 128) {
                        newPositions.push({
                            x: x - 500,
                            y: -(y - 150),
                            z: 0
                        });
                    }
                }
            }
            return newPositions;
        }

        function initParticles(wordIndex) {
            const data = createTextData(words[wordIndex]);
            const color = new THREE.Color(softColors[wordIndex]);
            
            particles = data.map(pos => ({
                pos: new THREE.Vector3(pos.x, pos.y, pos.z),
                dest: new THREE.Vector3(pos.x, pos.y, pos.z),
                vel: new THREE.Vector3(),
                acc: new THREE.Vector3(),
                color: color.clone()
            }));

            updateGeometry();
        }

        function updateGeometry() {
            const posArr = new Float32Array(particles.length * 3);
            const colorArr = new Float32Array(particles.length * 3);
            particles.forEach((p, i) => {
                posArr[i * 3] = p.pos.x;
                posArr[i * 3 + 1] = p.pos.y;
                posArr[i * 3 + 2] = p.pos.z;
                colorArr[i * 3] = p.color.r;
                colorArr[i * 3 + 1] = p.color.g;
                colorArr[i * 3 + 2] = p.color.b;
            });
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colorArr, 3));
        }

        // --- HAND TRACKING & INTERACTION ---
        const handPos = new THREE.Vector3(-999, -999, 0);
        let prevHandX = 0;
        let swipeThreshold = 0.05;

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmark = results.multiHandLandmarks[0][8]; // Đầu ngón trỏ
                
                // Chuyển tọa độ MediaPipe sang Three.js (Gương)
                const targetX = (1 - landmark.x - 0.5) * 1200;
                const targetY = -(landmark.y - 0.5) * 600;
                
                handPos.set(targetX, targetY, 20);

                // Detection Swipe (Lướt)
                const deltaX = landmark.x - prevHandX;
                if (Math.abs(deltaX) > swipeThreshold) {
                    if (deltaX > 0.1) changeWord(-1); // Lướt trái
                    if (deltaX < -0.1) changeWord(1); // Lướt phải
                }
                prevHandX = landmark.x;
            } else {
                handPos.set(-9999, -9999, 0);
            }
        }

        function changeWord(dir) {
            currentWordIndex = (currentWordIndex + dir + words.length) % words.length;
            initParticles(currentWordIndex);
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
        hands.onResults(onResults);

        const videoElement = document.getElementById('webcam');
        const bgVideo = document.getElementById('bg-video');
        const cam = new Camera(videoElement, {
            onFrame: async () => { 
                await hands.send({ image: videoElement }); 
                if (bgVideo.srcObject !== videoElement.srcObject) bgVideo.srcObject = videoElement.srcObject;
                bgVideo.play();
            },
            width: 1280, height: 720
        });
        cam.start();

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const mouseRadius = 60;
            const mouseStrength = 7;

            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                
                // Khoảng cách tới bàn tay
                const dx = handPos.x - p.pos.x;
                const dy = handPos.y - p.pos.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Lực đẩy khi chạm tay
                if (dist < mouseRadius) {
                    const angle = Math.atan2(dy, dx);
                    const force = (mouseRadius - dist) / mouseRadius;
                    p.acc.x -= Math.cos(angle) * force * mouseStrength;
                    p.acc.y -= Math.sin(angle) * force * mouseStrength;
                }

                // Lực đàn hồi kéo về vị trí cũ (Home force)
                p.acc.x += (p.dest.x - p.pos.x) * 0.05;
                p.acc.y += (p.dest.y - p.pos.y) * 0.05;

                // Vật lý cơ bản
                p.vel.add(p.acc);
                p.pos.add(p.vel);
                p.vel.multiplyScalar(0.9); // Ma sát
                p.acc.set(0, 0, 0);
            }

            updateGeometry();
            renderer.render(scene, camera);
        }

        // Khởi tạo lần đầu
        initParticles(0);
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
