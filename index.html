<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Text Effect - Dark Moody Mode</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #webcam { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: -2; transform: scaleX(-1); 
            filter: brightness(0.7) contrast(1.3) saturate(0.7); /* T·ªëi moody, tay v·∫´n r√µ */
        }
        /* L·ªõp overlay ƒëen m·ªù ƒë·ªÉ che th√™m, ki·ªÉu dim dark */
        #dark-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.35); /* M·ªù m·ªù ƒëen, che m·∫∑t nh·∫π nh∆∞ng th·∫•y tay */
            pointer-events: none; z-index: -1;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
       
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: white; pointer-events: none;
        }
        .status { background: rgba(0,0,0,0.6); padding: 12px 20px; border-radius: 8px; margin-bottom: 10px; border-left: 5px solid #00ffff; backdrop-filter: blur(4px); }
        #hint { 
            position: absolute; bottom: 20px; width: 100%; text-align: center; 
            color: white; text-shadow: 0 2px 8px rgba(0,0,0,0.9); z-index: 5; 
            font-size: 16px; font-weight: bold; line-height: 1.6;
        }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="dark-overlay"></div> <!-- L·ªõp che m·ªù ƒëen -->
   
    <div id="ui">
        <div class="status">
            <small>TAY 1 (CH·ªåN CH·ªÆ):</small>
            <div id="word-val" style="font-size: 26px; font-weight: bold;">Hello</div>
        </div>
        <div class="status">
            <small>TAY 2 (HI·ªÜU ·ª®NG):</small>
            <div id="effect-val" style="font-size: 18px;">CH∆ØA C√ì TAY 2</div>
        </div>
    </div>
    <div id="hint">
        Tay 1: Gi∆° 1-2-3 ng√≥n ƒë·ªÉ ƒë·ªïi ch·ªØ<br>
        Tay 2: N·∫Øm = ch·ªØ g·ªçn | M·ªü = ch·ªØ tan | Di tay g·∫ßn = h·∫°t bay lung linh<br>
        Gi·ªù n·ªÅn t·ªëi m·ªù m·ªù che m·∫∑t r·ªìi nha üòè
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const WORDS = ["Hello", "Thu√Ω L√¢m", "t l√† tr√πm tr∆∞·ªùng :))"];
        const MAX_PTS = 12000;
       
        let currentIdx = 0;
        let isActive2 = false;
        let isFist2 = false;
        let hand2Pos = new THREE.Vector3();
        let hand2Vel = new THREE.Vector3();

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
        camera.position.z = 600;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        function createCircleTexture() {
            const size = 64;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.3, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.6, 'rgba(200,255,255,0.4)');
            gradient.addColorStop(1, 'rgba(100,255,255,0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        const circleTexture = createCircleTexture();

        const particles = [];
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({
            size: 18,
            sizeAttenuation: false,
            map: circleTexture,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true
        });

        for (let i = 0; i < MAX_PTS; i++) {
            particles.push({
                curr: new THREE.Vector3(0, 0, -2000),
                dest: new THREE.Vector3(0, 0, -2000),
                vel: new THREE.Vector3(),
                acc: new THREE.Vector3(),
                color: new THREE.Color(0xffffff)
            });
        }
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        function getPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1200; canvas.height = 400;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 160px Arial';
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 600, 200);
           
            const data = ctx.getImageData(0, 0, 1200, 400).data;
            const pts = [];
            for (let y = 0; y < 400; y += 3) {
                for (let x = 0; x < 1200; x += 3) {
                    if (data[(x + y * 1200) * 4] > 100) {
                        pts.push({ 
                            x: (x - 600) * 1.3, 
                            y: -(y - 200) * 1.3 
                        });
                    }
                }
            }
            return pts;
        }

        function triggerWord(index) {
            if (index === currentIdx) return;
            currentIdx = index;
            const targetData = getPoints(WORDS[index]);
            const hue = Math.random() * 0.3 + 0.45;
            const newColor = new THREE.Color().setHSL(hue, 0.9, 0.6);
            
            particles.forEach((p, i) => {
                if (i < targetData.length) {
                    p.dest.set(targetData[i].x, targetData[i].y, 0);
                    p.curr.lerp(p.dest, 0.5);
                    p.vel.set(0,0,0);
                } else {
                    p.dest.set(0, 0, -2000);
                    p.curr.set(0, 0, -2000);
                }
                p.color.copy(newColor);
            });
            document.getElementById('word-val').innerText = WORDS[index];
        }

        triggerWord(0);

        function onResults(results) {
            const hands = results.multiHandLandmarks;
            if (hands && hands.length > 0) {
                const h1 = hands[0];
                const fingersUp = [8, 12, 16].filter(i => h1[i].y < h1[i-2].y).length;
                if (fingersUp >= 1 && fingersUp <= 3) triggerWord(fingersUp - 1);

                if (hands.length > 1) {
                    isActive2 = true;
                    const h2 = hands[1];
                    const newPos = new THREE.Vector3(
                        (1 - h2[9].x - 0.5) * 1100,
                        -(h2[9].y - 0.5) * 700,
                        0
                    );
                    hand2Vel.copy(newPos).sub(hand2Pos).multiplyScalar(0.3);
                    hand2Pos.copy(newPos);

                    const dist = Math.hypot(h2[8].x - h2[0].x, h2[8].y - h2[0].y);
                    isFist2 = dist < 0.2;

                    document.getElementById('effect-val').innerText = isFist2 
                        ? "‚úä SI·∫æT CH·∫∂T ‚Üí CH·ªÆ G·ªåN ƒê·∫∏P" 
                        : "üñêÔ∏è M·ªû TAY ‚Üí TAN & BAY LUNG LINH";
                } else {
                    isActive2 = false;
                    document.getElementById('effect-val').innerText = "CH∆ØA C√ì TAY 2";
                }
            } else {
                isActive2 = false;
            }
        }

        const handsAI = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        handsAI.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        handsAI.onResults(onResults);

        const video = document.getElementById('webcam');
        const cameraUtils = new Camera(video, { onFrame: async () => await handsAI.send({ image: video }), width: 1280, height: 720 });
        cameraUtils.start();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;

            const posArr = new Float32Array(MAX_PTS * 3);
            const colArr = new Float32Array(MAX_PTS * 3);

            particles.forEach((p, i) => {
                if (isActive2) {
                    if (isFist2) {
                        const force = 0.35;
                        p.acc.x += (p.dest.x - p.curr.x) * force;
                        p.acc.y += (p.dest.y - p.curr.y) * force;
                    } else {
                        const explode = 0.01;
                        p.acc.x += (p.curr.x - p.dest.x) * explode;
                        p.acc.y += (p.curr.y - p.dest.y) * explode;

                        const d = p.curr.distanceTo(hand2Pos);
                        if (d < 300) {
                            const strength = (300 - d) / 300;
                            const dir = p.curr.clone().sub(hand2Pos).normalize();
                            p.acc.add(dir.multiplyScalar(strength * 40));
                            p.acc.add(hand2Vel.clone().multiplyScalar(strength * 20));
                        }
                    }

                    p.vel.add(p.acc);
                    p.vel.multiplyScalar(0.88);
                    p.curr.add(p.vel);
                    p.acc.set(0,0,0);
                } else {
                    p.curr.lerp(p.dest, 0.12);
                }

                posArr[i*3]   = p.curr.x;
                posArr[i*3+1] = p.curr.y;
                posArr[i*3+2] = p.curr.z;
                colArr[i*3]   = p.color.r;
                colArr[i*3+1] = p.color.g;
                colArr[i*3+2] = p.color.b;
            });

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
