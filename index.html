<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Text Effect - Super Beautiful Neon Glow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Arial', sans-serif; }
        #webcam { 
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; z-index: -2; transform: scaleX(-1); 
            filter: brightness(0.7) contrast(1.3) saturate(0.7);
        }
        #dark-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.35); pointer-events: none; z-index: -1;
        }
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
       
        #ui {
            position: absolute; top: 20px; left: 20px; z-index: 10;
            color: white; pointer-events: none;
        }
        .status { background: rgba(0,0,0,0.6); padding: 12px 20px; border-radius: 8px; margin-bottom: 10px; border-left: 5px solid #ff00ff; backdrop-filter: blur(4px); }
        #hint { 
            position: absolute; bottom: 20px; width: 100%; text-align: center; 
            color: white; text-shadow: 0 2px 8px rgba(0,0,0,0.9); z-index: 5; 
            font-size: 16px; font-weight: bold; line-height: 1.6;
        }
    </style>
</head>
<body>
    <video id="webcam" autoplay playsinline muted></video>
    <div id="dark-overlay"></div>
   
    <div id="ui">
        <div class="status">
            <small>TAY 1 (CH·ªåN CH·ªÆ):</small>
            <div id="word-val" style="font-size: 26px; font-weight: bold;">Hello</div>
        </div>
        <div class="status">
            <small>TAY 2 (HI·ªÜU ·ª®NG):</small>
            <div id="effect-val" style="font-size: 18px;">CH∆ØA C√ì TAY 2</div>
        </div>
    </div>
    <div id="hint">
        Tay 1: Gi∆° 1-2-3 ng√≥n ƒë·ªÉ ƒë·ªïi ch·ªØ<br>
        Tay 2: N·∫Øm = ch·ªØ g·ªçn | M·ªü = ch·ªØ tan | Di tay g·∫ßn = h·∫°t bay neon lung linh<br>
        Gi·ªù h·∫°t si√™u ƒë·∫πp neon glow r·ªìi nha ‚ú®
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        const WORDS = ["Hello", "Thu√Ω L√¢m", "t l√† tr√πm tr∆∞·ªùng :))"];
        const MAX_PTS = 15000; // TƒÉng m·∫≠t ƒë·ªô ƒë·ªÉ ch·ªØ d√†y, m·ªãn h∆°n
       
        let currentIdx = 0;
        let isActive2 = false;
        let isFist2 = false;
        let hand2Pos = new THREE.Vector3();
        let hand2Vel = new THREE.Vector3();

        // --- THREE.JS SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 1, 3000);
        camera.position.z = 600;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 0);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // Texture h·∫°t m·ªÅm m·∫°i h∆°n: gradient neon cyan-magenta glow
        function createCircleTexture() {
            const size = 128; // TƒÉng ƒë·ªô ph√¢n gi·∫£i texture
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createRadialGradient(size/2, size/2, 0, size/2, size/2, size/2);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(100, 255, 255, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 0, 255, 0.6)');
            gradient.addColorStop(0.8, 'rgba(0, 255, 255, 0.3)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, size, size);
            return new THREE.CanvasTexture(canvas);
        }

        const circleTexture = createCircleTexture();

        const particles = [];
        const geo = new THREE.BufferGeometry();
        const mat = new THREE.PointsMaterial({
            size: 22, // TƒÉng size ƒë·ªÉ glow r√µ h∆°n
            sizeAttenuation: false,
            map: circleTexture,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true
        });

        for (let i = 0; i < MAX_PTS; i++) {
            particles.push({
                curr: new THREE.Vector3(0, 0, -2000),
                dest: new THREE.Vector3(0, 0, -2000),
                vel: new THREE.Vector3(),
                acc: new THREE.Vector3(),
                color: new THREE.Color(0xffffff)
            });
        }
        const points = new THREE.Points(geo, mat);
        scene.add(points);

        // T·∫°o ch·ªØ ƒë·∫πp h∆°n: font bold h∆°n, canvas l·ªõn h∆°n, sampling d√†y h∆°n
        function getPoints(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 1400; canvas.height = 500;
            ctx.fillStyle = 'white';
            ctx.font = 'bold 200px Arial Black, Arial'; // Bold m·∫°nh h∆°n
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillText(text, 700, 250);
           
            const data = ctx.getImageData(0, 0, 1400, 500).data;
            const pts = [];
            for (let y = 0; y < 500; y += 2) { // Sampling d√†y h∆°n (b∆∞·ªõc 2 thay v√¨ 3)
                for (let x = 0; x < 1400; x += 2) {
                    if (data[(x + y * 1400) * 4] > 80) {
                        pts.push({ 
                            x: (x - 700) * 1.4, 
                            y: -(y - 250) * 1.4 
                        });
                    }
                }
            }
            return pts;
        }

        function triggerWord(index) {
            if (index === currentIdx) return;
            currentIdx = index;
            const targetData = getPoints(WORDS[index]);
            
            // Palette neon cyberpunk ƒë·∫πp: random gi·ªØa magenta, cyan, purple, pink
            const palettes = [
                {h: 0.8, s: 1, l: 0.6}, // Magenta
                {h: 0.5, s: 1, l: 0.6}, // Cyan
                {h: 0.75, s: 0.9, l: 0.65}, // Purple
                {h: 0.9, s: 1, l: 0.7}  // Hot pink
            ];
            const pal = palettes[Math.floor(Math.random() * palettes.length)];
            const newColor = new THREE.Color().setHSL(pal.h, pal.s, pal.l);
            
            particles.forEach((p, i) => {
                if (i < targetData.length) {
                    p.dest.set(targetData[i].x, targetData[i].y, 0);
                    p.curr.lerp(p.dest, 0.6);
                    p.vel.set(0,0,0);
                } else {
                    p.dest.set(0, 0, -2000);
                    p.curr.set(0, 0, -2000);
                }
                p.color.copy(newColor);
            });
            document.getElementById('word-val').innerText = WORDS[index];
        }

        triggerWord(0);

        // --- HAND DETECTION ---
        function onResults(results) {
            const hands = results.multiHandLandmarks;
            if (hands && hands.length > 0) {
                const h1 = hands[0];
                const fingersUp = [8, 12, 16].filter(i => h1[i].y < h1[i-2].y).length;
                if (fingersUp >= 1 && fingersUp <= 3) triggerWord(fingersUp - 1);

                if (hands.length > 1) {
                    isActive2 = true;
                    const h2 = hands[1];
                    const newPos = new THREE.Vector3(
                        (1 - h2[9].x - 0.5) * 1200,
                        -(h2[9].y - 0.5) * 800,
                        0
                    );
                    hand2Vel.copy(newPos).sub(hand2Pos).multiplyScalar(0.3);
                    hand2Pos.copy(newPos);

                    const dist = Math.hypot(h2[8].x - h2[0].x, h2[8].y - h2[0].y);
                    isFist2 = dist < 0.2;

                    document.getElementById('effect-val').innerText = isFist2 
                        ? "‚úä SI·∫æT CH·∫∂T ‚Üí CH·ªÆ G·ªåN NEON" 
                        : "üñêÔ∏è M·ªû TAY ‚Üí TAN & BAY SI√äU ƒê·∫∏P";
                } else {
                    isActive2 = false;
                    document.getElementById('effect-val').innerText = "CH∆ØA C√ì TAY 2";
                }
            } else {
                isActive2 = false;
            }
        }

        const handsAI = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
        handsAI.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        handsAI.onResults(onResults);

        const video = document.getElementById('webcam');
        const cameraUtils = new Camera(video, { onFrame: async () => await handsAI.send({ image: video }), width: 1280, height: 720 });
        cameraUtils.start();

        // --- ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            const posArr = new Float32Array(MAX_PTS * 3);
            const colArr = new Float32Array(MAX_PTS * 3);

            particles.forEach((p, i) => {
                if (isActive2) {
                    if (isFist2) {
                        const force = 0.4;
                        p.acc.x += (p.dest.x - p.curr.x) * force;
                        p.acc.y += (p.dest.y - p.curr.y) * force;
                    } else {
                        const explode = 0.012;
                        p.acc.x += (p.curr.x - p.dest.x) * explode;
                        p.acc.y += (p.curr.y - p.dest.y) * explode;

                        const d = p.curr.distanceTo(hand2Pos);
                        if (d < 350) {
                            const strength = (350 - d) / 350;
                            const dir = p.curr.clone().sub(hand2Pos).normalize();
                            p.acc.add(dir.multiplyScalar(strength * 50));
                            p.acc.add(hand2Vel.clone().multiplyScalar(strength * 25));
                        }
                    }

                    p.vel.add(p.acc);
                    p.vel.multiplyScalar(0.89);
                    p.curr.add(p.vel);
                    p.acc.set(0,0,0);
                } else {
                    p.curr.lerp(p.dest, 0.15);
                }

                posArr[i*3]   = p.curr.x;
                posArr[i*3+1] = p.curr.y;
                posArr[i*3+2] = p.curr.z;
                colArr[i*3]   = p.color.r;
                colArr[i*3+1] = p.color.g;
                colArr[i*3+2] = p.color.b;
            });

            geo.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            geo.setAttribute('color', new THREE.BufferAttribute(colArr, 3));
            geo.attributes.position.needsUpdate = true;
            geo.attributes.color.needsUpdate = true;

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
