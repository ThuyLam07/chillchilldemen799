<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic 3D Particles & Gestures</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@800&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Montserrat', sans-serif; }
        
        /* Video nền toàn màn hình */
        #bg-video {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover;
            z-index: -2; /* Nằm dưới cùng */
            transform: scaleX(-1); /* Lật ngược video như gương */
            filter: brightness(0.7) contrast(1.2); /* Làm tối video một chút để làm nổi bật hạt */
        }

        /* Canvas 3D nằm đè lên video */
        canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; pointer-events: none;}

        /* Giao diện điều khiển nhỏ góc trái */
        #ui-controls {
            position: absolute;
            top: 20px; left: 20px; z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px; border-radius: 8px;
            backdrop-filter: blur(5px); color: white; font-size: 12px;
        }

        /* Chữ năng động chính giữa màn hình */
        #dynamic-overlay-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 5;
            font-size: 8vw; /* Kích thước chữ lớn dựa trên độ rộng màn hình */
            font-weight: 800;
            text-transform: uppercase;
            text-align: center;
            /* Hiệu ứng chữ outline và bóng đổ để dễ đọc trên nền video */
            -webkit-text-stroke: 2px rgba(255,255,255,0.1);
            text-shadow: 0 0 30px rgba(0,0,0,0.8);
            transition: all 0.3s ease-out;
            pointer-events: none;
            /* Màu sắc sẽ được cập nhật bằng JS */
            color: #fff; 
        }
    </style>
</head>
<body>

    <video id="bg-video" playsinline></video>

    <div id="dynamic-overlay-text">LOADING AI...</div>

    <div id="ui-controls">
        Sử dụng 2 tay để tương tác.
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- CẤU HÌNH THREE.JS (Visuals) ---
        const scene = new THREE.Scene();
        // Quan trọng: alpha: true để nền trong suốt
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 4;

        // --- HỆ THỐNG HẠT NÂNG CẤP ---
        const particleCount = 6000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const originalCoords = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount); // Mảng lưu kích thước hạt

        for (let i = 0; i < particleCount; i++) {
            // Tạo hình cầu
            const phi = Math.acos(-1 + (2 * i) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            
            // Thêm một chút nhiễu (randomness) để hình cầu trông tự nhiên hơn
            const radius = 1.0 + (Math.random() - 0.5) * 0.1; 
            const x = radius * Math.cos(theta) * Math.sin(phi);
            const y = radius * Math.sin(theta) * Math.sin(phi);
            const z = radius * Math.cos(phi);

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;
            originalCoords[i * 3] = x;
            originalCoords[i * 3 + 1] = y;
            originalCoords[i * 3 + 2] = z;

            // Kích thước hạt ngẫu nhiên
            sizes[i] = Math.random() * 0.03 + 0.005;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        // Shader Material tùy chỉnh để hạt có kích thước khác nhau và màu sắc động
        const material = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0xffffff) },
                scale: { value: window.innerHeight / 2.0 } // Hệ số scale theo màn hình
            },
            vertexShader: `
                attribute float size;
                uniform float scale;
                void main() {
                    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
                    // Kích thước hạt thay đổi theo khoảng cách tới camera
                    gl_PointSize = size * scale * ( 3.0 / - mvPosition.z );
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                uniform vec3 color;
                void main() {
                    // Tạo hình tròn cho hạt thay vì hình vuông
                    if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.475) discard;
                    gl_FragColor = vec4( color, 1.0 );
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthTest: false
        });

        const particleSystem = new THREE.Points(geometry, material);
        scene.add(particleSystem);

        // --- XỬ LÝ MEDIAPIPE & TRẠNG THÁI ---
        const videoElement = document.getElementById('bg-video');
        const overlayText = document.getElementById('dynamic-overlay-text');
        
        let currentScale = 1;
        let targetScale = 1;
        let handDistance = 0;
        let handsDetected = false;
        let hueOffset = 0; // Dùng để xoay vòng màu sắc

        // Danh sách từ hiển thị khi không có tương tác
        const idleWords = ["HELLO", "FUTURE", "XU", "WAVE HANDS", "INTERACT"];
        let idleWordIndex = 0;
        setInterval(() => {
             if (!handsDetected) {
                idleWordIndex = (idleWordIndex + 1) % idleWords.length;
                overlayText.innerText = idleWords[idleWordIndex];
             }
        }, 2000); // Đổi từ mỗi 2 giây khi rảnh

        function onResults(results) {
            handsDetected = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length >= 2) {
                const hand1 = results.multiHandLandmarks[0][9]; // Lấy khớp giữa lòng bàn tay cho ổn định
                const hand2 = results.multiHandLandmarks[1][9];

                // Tính khoảng cách
                handDistance = Math.sqrt(Math.pow(hand1.x - hand2.x, 2) + Math.pow(hand1.y - hand2.y, 2));
                // Map khoảng cách sang tỉ lệ (ví dụ: 0.1 -> 1.0, 0.8 -> 5.0)
                targetScale = 1 + Math.max(0, (handDistance - 0.1) * 6);

                // Cập nhật chữ dựa trên hành động
                if (targetScale > 3.5) {
                     overlayText.innerText = "UNLEASH";
                } else if (targetScale > 2.0) {
                     overlayText.innerText = "EXPAND";
                } else {
                     overlayText.innerText = "SPHERE";
                }
            } else if (handsDetected && results.multiHandLandmarks.length === 1) {
                 targetScale = 1.2; // Hơi mở nhẹ khi có 1 tay
                 overlayText.innerText = "NEED 2 HANDS";
            } else {
                targetScale = 0.8; // Thu nhỏ lại khi không có tay
                // Text được xử lý bởi setInterval ở trên
            }
        }

        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        hands.onResults(onResults);

        const cam = new Camera(videoElement, {
            onFrame: async () => { await hands.send({ image: videoElement }); },
            width: 1280, height: 720 // Độ phân giải camera cao hơn
        });
        cam.start();

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. Màu sắc động (Rainbow effect)
            hueOffset += 0.005;
            const hue = hueOffset % 1; 
            // Màu cho hạt (Saturation cao, Lightness trung bình)
            material.uniforms.color.value.setHSL(hue, 1.0, 0.6);
            // Màu cho chữ (Màu tương phản hoặc cùng tông nhưng sáng hơn)
            const textHue = (hue + 0.1) % 1; // Lệch pha một chút
            overlayText.style.color = `hsl(${textHue * 360}, 100%, 75%)`;
            // Thêm hiệu ứng glow cho chữ cùng màu
            overlayText.style.textShadow = `0 0 30px hsl(${textHue * 360}, 100%, 50%)`;


            // 2. Vật lý hạt
            currentScale += (targetScale - currentScale) * 0.08; // Lerp mượt mà

            const posAttr = geometry.attributes.position;
            for (let i = 0; i < particleCount; i++) {
                // Vị trí cơ bản dựa trên scale
                let x = originalCoords[i * 3] * currentScale;
                let y = originalCoords[i * 3 + 1] * currentScale;
                let z = originalCoords[i * 3 + 2] * currentScale;

                // THÊM HIỆU ỨNG "THỞ" NGẪU NHIÊN KHI MỞ RỘNG
                if (currentScale > 1.5) {
                    const noise = Math.sin(i + hueOffset * 5) * (currentScale * 0.05);
                    x += noise; y += noise; z += noise;
                }

                posAttr.array[i * 3] = x;
                posAttr.array[i * 3 + 1] = y;
                posAttr.array[i * 3 + 2] = z;
            }
            posAttr.needsUpdate = true;

            // 3. Xoay hệ thống
            particleSystem.rotation.y += 0.003;
            // Xoay nhanh hơn khi mở rộng
            particleSystem.rotation.z += (currentScale - 1) * 0.005;

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.scale.value = window.innerHeight / 2.0; // Cập nhật scale cho shader
        });

        animate();
    </script>
</body>
</html>
